<!--  put in a key for the graph, only grabbing FeatureCollection 
		put in a click function -->

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<script type="text/javascript" src="d3.min.js"></script>
<script src="http://d3js.org/topojson.v0.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
<script src="http://code.jquery.com/ui/1.9.2/jquery-ui.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.9.0/d3-legend.js"></script>
<script src="colorbrewer.js"></script>
<link type="text/css" rel="stylesheet" href="mapp.css">
</head>
<body onload="loadBaseMap('Referencemap.json')">

<div id="interactive_panel">
	<div style="display:inline-block; vertical-align:center; font-size: 23px">Cartogram of world's</div>
	<select id="selectBar"  onChange="changeDataset(this.options[this.selectedIndex].innerHTML);"></select>
	<div style="display:inline-block; vertical-align:center; font-size: 23px">showing</div>
	<select id="selectBarColor" onChange="changeAttribute(this.options[this.selectedIndex].innerHTML)"></select>
</div>

<div id="description"></div>
<div id="acknowledge">
	<p><strong>Acknowledge</strong>: The cartogram implementation is designed and built by Amanda Hinchman-Dominguez and<a href="https://www.grinnell.edu/users/caoyujin"> Yujing Cao </a>at <a href="http://dasil.grinnell.edu/">DASIL</a></p>
</div>
<div id="tooltip"></div>
<div id="tooltipTest"></div>

<script id="map">

	 var div = d3.select("body").append("div")
	 			.style("position","relative")
	 			.attr("id", "tooltipTest")
	 			.style("opacity", 0.9);

	d3.csv("filelist.csv", function(data) {
		d3.select("#selectBar").selectAll("option")
						.data(data)
						.enter()
						.append("option")
						.attr("id", function(d,i) {
							return ("option" + i);
						})
						.text(function(d) {
							return d.FileNames;
						});
	});
    
    // Generate dropdow list with JSON file of attributes
	var attributesJSON=d3.json("Attributes.json",function(json){
		attributesJSON=json;
		d3.select("#selectBarColor").selectAll("option")
							.data(attributesJSON)
							.enter()
							.append("option")
							.attr("id", function(d,i) {
								return ("option" + i)
							})
							.text(function(d) {
								if (d.name!="Unknown"){
									return d.name;
								}else{
									return d.id;
								}
							})
							.attr("title",function(d){
								return d.name;
							});
	});

    
    // Load Attributes json file
    var attributesJSON=d3.json("Attributes.json",function(json){
		attributesJSON=json;
	});
    
	var json = d3.json("Population.json"); 

	var tooltip = d3.select('text')
						.append('div')
						.attr('class', 'tooltip');
	var currentpath = "";

	var currentjson = "";
	var toggle=0;
 
     // Function to remove all the missing values. Missing data is coded as "-999"
    function removeElement(arr){
    	var what, a = arguments, L = a.length, ax;
		while (L > 1 && arr.length) {
    		what = a[--L];
   			while ((ax= arr.indexOf(what)) !== -1) {
       		arr.splice(ax, 1);
    	}
		 }
		return arr;
	}
   
    // Showing the base map in the large svg area

    function loadBaseMap(dataset){
    	var base_color = d3.scale.category20();
	// Add reference map
		var svg_base=d3.select("body").append("svg")
		.attr("id","mySVG")
		.attr("width",window.innerWidth)
		.attr("height",window.innerHeight);

		d3.json(dataset, function(data){
			var group=svg_base.selectAll("g")
			.data(data.features)
			.enter()
			.append("g")

			var projection=d3.geo.mercator()
				.scale(180)
				.center(d3.geo.centroid(data))
				.translate([990,410]);

			var path=d3.geo.path().projection(projection);

			var areas=group.append("path")
			.attr("d", path)
			.attr("class","area")
			.style("fill",function(d){
				return base_color(d.properties.ADMIN);
			});
		});
    }

function loadImage(dataset) {
    
    d3.selectAll("#mySVG").transition().duration(2000).ease("elastic").remove();
	var attribute=document.getElementById('selectBarColor').value;
	var fullname;
	var attribute_1;
	var active;
    
    attributesJSON.forEach(function(d){
    	if (d.name==attribute){
    		return attribute_1=d.id;
    	}
    });

    if (attribute==="Select an Attribute"){
    	fullname="GDP per Capita";
    	attribute=attribute_1="GDPPCAP";
    	attributesJSON.forEach(function(d){
        	if (d.id=="GDPPCAP"){
        		return unit=d.unit;
        	}
        });
    }else{
    	attributesJSON.forEach(function(d){
        	if (d.name==attribute){
        		return fullname=d.name;
        	}
        });
        attributesJSON.forEach(function(d){
        	if (d.name==attribute){
        		return unit=d.unit;
        	}
        });
    }
    
		currentjson = dataset;

		var margin = {
			top: 20,
			right: 10,
			bottom: 30,
			left: 10
		};
	
		var h = window.innerHeight; 
		var w = window.innerWidth;
		var padding = 50;
		var countryattr = [];
		var color = [];
		var centered;

		var svg = d3.select("body").append("svg")
			//a box to contain the map
			.attr("id", "mySVG")
		    .attr("width", w)
			.attr("height", h);
	
		var g=svg.append("g");
			//accesses the json and creates a projection
		var map = d3.json(dataset, function (json) {
			// create a first guess for the projection
			var center = d3.geo.centroid(json);
			var scale = 180;
			var offset = [w / 2, h / 2];
			var projection = d3.geo.mercator().scale(scale).center(center)
    			.translate(offset);

			// create the path
			var path = d3.geo.path().projection(projection);
			
			// using the path to determine the bounds of the current
			// bounds of the current map and use these to determine
			// better values for scale and translation
			var bounds = path.bounds(json);

			var hscale = scale*w / (bounds[1][0] - bounds[0][0]);
			var vscale = scale*h / (bounds[1][1] - bounds[0][1]);
			var scale = (hscale < vscale) ? hscale : vscale;
            
			var offset = [w - 1.05*(bounds[0][0] + bounds[1][0])/2, 
									h - 1.1*(bounds[0][1] + bounds[1][1])/2];


			//NOTE: FIX OFFSET BUT I THINK ITS PERMANENT NOW
			// new projection
			projection = d3.geo.mercator().center(center)
							.scale(scale*0.9).translate(offset);
			path = path.projection(projection);
			
			for (var i = 0; i < json.features.length; i++) {
 				countryattr[i] = json.features[i].properties[attribute_1];
 			}

 			// Store countryattr in countryattr_missing and remove missing values from countryattr
             
            var countryattr_missing=[];
            for (var i=0; i<countryattr.length; i++){
            	countryattr_missing.push(countryattr[i]);
            }

 			removeElement(countryattr,-999)
		    
			//sets a quantized scale based on the automatically-calculated data range
			var colorScale = d3.scale.quantile()
							.range(['#ffffcc','#a1dab4',
								'#41b6c4','#225ea8'])
							.domain(countryattr);

            var thresholds=colorScale.quantiles();
			// var colorScale = d3.scale.quantize()
			// 				.range(colorbrewer.Blues[4])
			// 				.domain([d3.min(countryattr), d3.max(countryattr)]);
			//links the data variable to the color scale
			for (var i = 0; i < json.features.length; i++) {
				if (countryattr_missing[i]!=-999){
					color[i] = colorScale(countryattr_missing[i]);
				}else{
					color[i]="grey";
				}	
 			}

		var legendLabel=[];

		legendLabel[0]="< "+thresholds[0].toFixed(2);
		legendLabel[1]=thresholds[0].toFixed(2)+" to "+thresholds[1].toFixed(2);
		legendLabel[2]=thresholds[1].toFixed(2)+" to "+thresholds[2].toFixed(2);
		legendLabel[3]="> "+thresholds[2].toFixed(2);
				 
			// Add legend 
			var colors=[];

			for (var i=0;i<colorScale.range().length;i++){
				colors.push(colorScale.range()[i]);
			}

			colors.push("grey");

			var svg=d3.selectAll("#mySVG");
			    
            var legend=svg.selectAll('.legend')
			             .data(colors)
                         .enter()
                         .append("g")
                         .attr("class","legend");
						 
                 legend.append("rect")
                         .attr("x",30)	
                         .attr("y",function(d,i){
						 return 120+i*40;
						 })							 
			             .attr("width",30)
						 .attr("height",40)
						 .style("fill",function(d,i){
						 return colors[i];
						 });
                var legendLabel_1=[];
                for (var i=0;i<legendLabel.length;i++){
                	legendLabel_1.push(legendLabel[i]);
                }
                legendLabel_1.push("missing value(-999)");

				legend.append("text")
				         .attr("x",75)
						 .attr("y",function(d,i){
						 return 145+i*40;
						 })
				         .text(function(d,i){
						     return legendLabel_1[i];
						 });
				 legend.append("text")
				 		.attr("x",30)
				 		.attr("y",70)
				 		.text(fullname);
				 legend.append("text")
				 	   .attr("x",30)
				 	   .attr("y",105)
				 	   .text("Unit: "+unit);
 			var lock;
 		
			//makes the map
			g.selectAll("path")
				.data(json.features)
				.enter()
				.append("path")
				.transition()
				.duration(1000)
				.ease("elastic")
				.attr("d", d3.geo.path().projection(projection))
				.attr("stroke", "black")
				.attr("fill", function(json, i) {
						return color[i];
					});
												
				g.selectAll("path")
					.on("mouseover", function(d) {
					var mouse = d3.mouse(svg.node()).map(function(d) { return parseInt(d); });
					var dis = d3.select(this);
                      
					div.transition()
						.duration(200)
						.style("opacity", .9);

					div.html(d.properties.ADMIN + "<br/>"+"Total Population"+d.properties.POPULAT+"<br>")
						.style("position", "absolute")
					    .style("x", (mouse[0]) + "px")
					    .style("y", (mouse[1]) + "px");

					if (lock) {
						d3.event.stopPropagation();
						dis.style('stroke-width', '2px')
							.style('fill-opacity', 2)
							.style('stroke',"red");
					} else {
						dis.style('stroke-width', '2px')
							.style('fill-opacity', 2)
							.style('stroke',"red");

						var tooltipDiv = document.getElementById('tooltip');
							tooltipDiv.innerHTML = d.properties.ADMIN + "<br/>" + 
							"Total Population: " + d.properties.POPULAT + "<br/>";
							tooltipDiv.style.display = "block";

					}
				})
				.on("click", function(d) {
					var dis = d3.select(this);
					if (toggle==0){
						dis.style('stroke-width', '2px')
 					 		.style('fill-opacity', 2);
 						var tooltipDiv = document.getElementById('tooltip');
 						tooltipDiv.style.display = "block"; 
						tooltipDiv.innerHTML = 
						"Selected Country: " + d.properties.ADMIN + "<br/>" + 
						"Total Population: " + d.properties.POPULAT + "<br/>" +
						fullname+": " + d.properties[attribute_1] + "<br/>";
 					 	toggle=1;
 					 	lock = true;
			 		}else{
						dis.style('stroke-width', '1px')
 					 		.style('fill-opacity', 2)
 					 		.style('fill',dis.attr('fill'));
 					 		var tooltipDiv = document.getElementById('tooltip');
 								tooltipDiv.style.display = "none";
							toggle=0;
			 		}
 				})
				.on("mouseout", function(d) {
					div .transition()
						.duration(0)
						.style("opacity", 0);
					div .html(d.properties.ADMIN + "<br/>" + 
						"Total Population: " + d.properties.POPULAT + "<br/>")
					    .style("left", (d3.event.pageX) + "px")
					    .style("top", (d3.event.pageY - 28) + "px"); 

					if (lock) {
						d3.select(this).style('stroke-width', '1px')
 							.style('fill-opacity', 1)
 							.style('stroke',"black");
 						var tooltipDiv = document.getElementById('tooltip');
 						if (toggle==0){
 							tooltipDiv.style.display = "none";
 						}else{
 							tooltipDiv.style.display = "block";
 						}
					} else {
 						d3.select(this).style('stroke-width', '1px')
 								.style('fill-opacity', 1)
 								.style('stroke',"black");
 						var tooltipDiv = document.getElementById('tooltip');
 		             	if (toggle==0){
 							tooltipDiv.style.display = "none";
 						}else{
 							tooltipDiv.style.display = "block";
 						}
					}
 				})
 				.on("dblclick", function(d){
 					var x, y, k;

					  if (d && centered !== d) {
					    var centroid = path.centroid(d);
					    x = centroid[0];
					    y = centroid[1];
					    k = 1.5;
					    centered = d;
					  } else {
					    x = w / 2;
					    y = h / 4;
					    k = 1;
					    centered = null;
					  }

					  g.selectAll("path")
					      .classed("active", centered && function(d) { return d === centered; });

					  g.transition()
					      .duration(750)
					      .attr("transform", "translate(" + w / 2 + "," + h / 4+ ")scale(" + k + ")translate(" + -x + "," + -y + ")");
					 				});
 				//.call(zoom);
		});
	}// loadImage()
		
	function changeDataset(dataset) {	

		d3.selectAll("#mySVG").transition().duration(5000).ease("elastic").remove();
		//d3.selectAll("#mySVG").remove();
		loadImage(dataset + ".json") 
	}// changeDataset()

	function changeAttribute(attribute) {
		d3.selectAll("#mySVG").transition().duration(1000).ease("elastic").remove();
		var countryattr = [];
		var countryattr_missing=[];
		var color = [];
		var lock;
		var toggle=0;
	    var fullname;
	    var unit;
	    var attribute_1;
	    var detail;
	    var dataSource;
	    var centered;
		//grab data from current dataset
		var dataset = currentjson;
		var h = window.innerHeight; 
		var w = window.innerWidth;
		var padding = 50;

		var svg = d3.select("body").append("svg")
			//a box to contain the map
			.attr("id", "mySVG")
		    .attr("width", w)
			.attr("height", h);
	
		var g=svg.append("g");

		// get the id of corresponding selected attribute
		attributesJSON.forEach(function(d){
			if (d.name==attribute){
				return attribute_1=d.id;
			}
		});

        // get the full name of attribute
        attributesJSON.forEach(function(d){
        	if (d.name==attribute){
        		return fullname=d.name;
        	}
        });
      	attributesJSON.forEach(function(d){
        	if (d.name==attribute){
        		return unit=d.unit;
        	}
        });

      	attributesJSON.forEach(function(d){
      		if (d.name==attribute){
      			return detail=d.description;
      		}
      	});
        
	    attributesJSON.forEach(function(d){
        	if (d.name==attribute){
        		return dataSource=d.source; 
        	}
        });

      	attributesJSON.forEach(function(d){
      		if (d.name!="Select an Attribute"){
      			document.getElementById("description").style.display="block";
      		}
      	})

      	
      	document.getElementById("description").innerHTML="<strong>"+attribute+"</strong>:"+"<br>"+detail+"<br>"+"<strong>"+"Data Source:"+"</strong>"+"<br>"+dataSource;

		var map = d3.json(dataset, function (json) {

			var center = d3.geo.centroid(json);
			var scale = 180;
			var offset = [w / 2, h / 2];
			var projection = d3.geo.mercator().scale(scale).center(center)
    			.translate(offset);

			// create the path
			var path = d3.geo.path().projection(projection);
			
			// using the path to determine the bounds of the current
			// bounds of the current map and use these to determine
			// better values for scale and translation
			var bounds = path.bounds(json);

			var hscale = scale*w / (bounds[1][0] - bounds[0][0]);
			var vscale = scale*h / (bounds[1][1] - bounds[0][1]);
			var scale = (hscale < vscale) ? hscale : vscale;
            
			var offset = [w - 1.05*(bounds[0][0] + bounds[1][0])/2, 
									h - 1.1*(bounds[0][1] + bounds[1][1])/2];


			//NOTE: FIX OFFSET BUT I THINK ITS PERMANENT NOW
			// new projection
			projection = d3.geo.mercator().center(center)
							.scale(scale*0.9).translate(offset);
			path = path.projection(projection);
			
			for (var i = 0; i < json.features.length; i++) {
 				countryattr[i] = json.features[i].properties[attribute_1];
 			}

 			// Store countryattr in countryattr_missing and remove missing values from countryattr
             
             var countryattr_missing=[];
            for (var i=0; i<countryattr.length; i++){
            	countryattr_missing.push(countryattr[i]);
            }


 			removeElement(countryattr,-999);
		    
			//sets a quantized scale based on the automatically-calculated data range
			var colorScale = d3.scale.quantile()
							.range(['#ffffcc','#a1dab4',
								'#41b6c4','#225ea8'])
							.domain(countryattr);
            
             var thresholds=colorScale.quantiles();

			//links the data variable to the color scale
			for (var i = 0; i < json.features.length; i++) {
				if (countryattr_missing[i]!=-999){
					color[i] = colorScale(countryattr_missing[i]);
				}else{
					color[i]="grey";
				}	
 			}
	
		var legendLabel=[];
			
        legendLabel[0]="< "+thresholds[0].toFixed(2);
		legendLabel[1]=thresholds[0].toFixed(2)+" to "+thresholds[1].toFixed(2);
		legendLabel[2]=thresholds[1].toFixed(2)+" to "+thresholds[2].toFixed(2);
		legendLabel[3]="> "+thresholds[2].toFixed(2);

            var colors=[];

			for (var i=0;i<colorScale.range().length;i++){
				colors.push(colorScale.range()[i]);
			}

			colors.push("grey");

			var svg=d3.selectAll("#mySVG");
			   svg.selectAll('.legend')
				   .remove();

            var legend=svg.selectAll('.legend')
			             .data(colors)
                         .enter()
                         .append("g")
                         .attr("class","legend");
						 
                legend.append("rect")
                         .attr("x",30)	
                         .attr("y",function(d,i){
						 return 120+i*40;
						 })							 
			             .attr("width",30)
						 .attr("height",40)
						 .style("fill",function(d,i){
						 return colors[i];
						 });

				var legendLabel_1=[];
                
                for (var i=0;i<legendLabel.length;i++){
                	legendLabel_1.push(legendLabel[i]);
                }
                
                legendLabel_1.push("missing value(-999)");

				 legend.append("text")
				         .attr("x",75)
						 .attr("y",function(d,i){
						 return 145+i*40;
						 })
				         .text(function(d,i){
						     return legendLabel_1[i];
						 });
				 legend.append("text")
				 		.attr("x",30)
				 		.attr("y",70)
				 		.text(fullname);
				 legend.append("text")
				 	   .attr("x",30)
				 	   .attr("y",105)
				 	   .text("Unit: "+unit);

			g.selectAll("path")
				.data(json.features)
				.enter()
				.append("path")
				.transition()
				.duration(1000)
				.ease("elastic")
				.attr("d", d3.geo.path().projection(projection))
				.attr("stroke", "black")
				.attr("fill", function(json, i) {
						return color[i];
					}); //missing data is grey
			
					g.selectAll("path")
					    .on("mouseover", function(d) {
						var mouse = d3.mouse(svg.node()).map(function(d) { return parseInt(d); });
						var dis = d3.select(this);
					
						div.transition()
							.duration(200)
							.style("opacity", .9);
						div.html(d.properties.ADMIN + "<br/>"+"Total Population"+d.properties.POPULAT+"<br>")
							.style("position", "absolute")
					    	.style("x", (mouse[0]) + "px")
					    	.style("y", (mouse[1]) + "px");
						if (lock) {
							d3.event.stopPropagation();
							dis.style('stroke-width', '2px')
								.style('fill-opacity', 2)
								.style('stroke',"red");
						} else {
							dis.style('stroke-width', '2px')
								.style('fill-opacity', 2)
								.style('stroke',"red");
							
						var tooltipDiv = document.getElementById('tooltip');
							tooltipDiv.innerHTML = d.properties.ADMIN + "<br/>" + 
							"Total Population: " + d.properties.POPULAT + "<br/>";
							tooltipDiv.style.display = "block";
					}
				})
				.on("click", function(d) {
					var dis = d3.select(this);
					if (toggle==0){
						dis.style('stroke-width', '2px')
 					 		.style('fill-opacity', 2);
 						var tooltipDiv = document.getElementById('tooltip');
 						tooltipDiv.style.display = "block"; 
						tooltipDiv.innerHTML = 
						"Selected Country: " + d.properties.ADMIN + "<br/>" + 
						"Total Population: " + d.properties.POPULAT + "<br/>" +
						fullname+": " + d.properties[attribute_1] + "<br/>";
						toggle=1;
						lock=true;

			 		}else{
						dis.style('stroke-width', '1px')
 					 		.style('fill-opacity', 2)
 					 		.style('fill',dis.attr('fill'));
 					 		toggle=0;
 					 		var tooltipDiv = document.getElementById('tooltip');
 								tooltipDiv.style.display = "none"; 
							toggle=0;
			 		}
 				})
				.on("mouseout", function(d) {
					var tooltipDiv = document.getElementById('tooltip');
					div .transition()
						.duration(200)
						.style("opacity", .0);
					div .html(d.properties.CNTRY_NAME + "<br/>" + 
						"Total Population: " + d.properties.POPULAT + "<br/>")
					    .style("left", (d3.event.pageX) + "px")
					    .style("top", (d3.event.pageY - 28) + "px"); 
					if (lock) {
						d3.select(this).style('stroke-width', '1px')
 							.style('fill-opacity', 1)
 							.style('stroke',"black");
 						if (toggle==0){
 							tooltipDiv.style.display = "none";
 						}else{
 							tooltipDiv.style.display = "block";
 						}
 						
					} else {
 						d3.select(this).style('stroke-width', '1px')
 								.style('fill-opacity', 1)
 								.style('stroke',"black");
 		             	if (toggle==0){
 							tooltipDiv.style.display = "none";
 						}else{
 							tooltipDiv.style.display = "block";
 						}
					}
 				})
 				.on("dblclick", function(d){
 					var x, y, k;

					  if (d && centered !== d) {
					    var centroid = path.centroid(d);
					    x = centroid[0];
					    y = centroid[1];
					    k = 1.5;
					    centered = d;
					  } else {
					    x = w / 2;
					    y = h / 2;
					    k = 1;
					    centered = null;
					  }

					  g.selectAll("path")
					      .classed("active", centered && function(d) { return d === centered; });

					  g.transition()
					      .duration(750)
					      .attr("transform", "translate(" + w / 2 + "," + h / 2 + ")scale(" + k + ")translate(" + -x + "," + -y + ")");
				});
		});
	}// changeAttribute()
		
</script>
</body>
</html>